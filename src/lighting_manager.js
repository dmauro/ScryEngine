// Generated by CoffeeScript 1.8.0

/*
This class is in charge of calculating
the lighting of every tile that is active
based on all light sources. The lighting
manager does not need to consider z coordinates
 */

(function() {
  var max_distance_for_brightest_light,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  max_distance_for_brightest_light = 30;

  engine.lighting.LightingManager = (function(_super) {
    __extends(LightingManager, _super);

    function LightingManager() {
      this.light_map = new engine.utils.MatrixArray();
      this.subcategory_cnames = ["engine.things.LightSource"];
      LightingManager.__super__.constructor.call(this);
    }

    LightingManager.prototype.constructor_for_name = function(name) {
      switch (name) {
        case "light_tile":
          return engine.lighting.LightTile;
      }
    };

    LightingManager.prototype._get_light_sources_that_need_updates = function() {
      var light_source, need_updates, _i, _len, _ref;
      need_updates = [];
      _ref = this.things;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        light_source = _ref[_i];
        if (light_source.needs_update) {
          need_updates.push(light_source);
        }
      }
      return need_updates;
    };

    LightingManager.prototype._calculate_radius_for_intensity = function(intensity) {
      return Math.round(intensity * max_distance_for_brightest_light);
    };

    LightingManager.prototype._calculate_radius_for_light_source = function(light_source) {
      return this._calculate_radius_for_intensity(light_source.intensity);
    };

    LightingManager.prototype._get_brightness_for_distance_and_intensity = function(distance, intensity) {
      var intensity_at_distance, steps;
      distance += 0.25;
      intensity_at_distance = intensity * ((max_distance_for_brightest_light - distance) / max_distance_for_brightest_light);
      steps = 5;
      intensity_at_distance = Math.round(intensity_at_distance * steps) / steps;
      return intensity_at_distance;
    };

    LightingManager.prototype._get_affected_positions_for_origin_and_radius = function(x, y, radius) {
      var distance, px, py, smooth_radius, within, _i, _j, _ref, _ref1, _ref2, _ref3;
      within = [];
      smooth_radius = radius + 0.25;
      for (py = _i = _ref = y - radius, _ref1 = y + radius + 1; _ref <= _ref1 ? _i < _ref1 : _i > _ref1; py = _ref <= _ref1 ? ++_i : --_i) {
        for (px = _j = _ref2 = x - radius, _ref3 = x + radius + 1; _ref2 <= _ref3 ? _j < _ref3 : _j > _ref3; px = _ref2 <= _ref3 ? ++_j : --_j) {
          distance = engine.utils.get_distance_between_points([x, y], [px, py]);
          if (distance <= smooth_radius) {
            within.push([px, py]);
          }
        }
      }
      return within;
    };

    LightingManager.prototype._get_affected_tile_positions = function(light_source) {
      return this._get_affected_positions_for_origin_and_radius(light_source.x, light_source.y, this._calculate_radius_for_light_source(light_source));
    };

    LightingManager.prototype.subcategory_thing_added = function(light_source) {
      light_source.on("light_intensity_updated", this._light_intensity_updated, this).on("light_color_updated", this._light_color_updated, this).on("light_position_updated", this._light_position_updated, this).on("light_applied", this._new_light_added_handler, this);
      return this._new_light_added(light_source);
    };

    LightingManager.prototype.subcategory_thing_removed = function(light_source) {
      light_source.off("light_intensity_updated", this._light_intensity_updated).off("light_color_updated", this._light_color_updated).off("light_position_updated", this._light_position_updated).off("light_applied", this._new_light_added_handler);
      return this._light_removed(light_source);
    };

    LightingManager.prototype._new_light_added_handler = function(event) {
      return this._new_light_added(event.target);
    };

    LightingManager.prototype._new_light_added = function(light_source) {
      var LightTile, light_tile, position, tile_positions, x, y, _i, _len, _results;
      if (!light_source.has_target) {
        return;
      }
      tile_positions = this._get_affected_tile_positions(light_source);
      LightTile = this.constructor_for_name("light_tile");
      _results = [];
      for (_i = 0, _len = tile_positions.length; _i < _len; _i++) {
        position = tile_positions[_i];
        x = position[0];
        y = position[1];
        light_tile = this.light_map.get_value_at(x, y);
        if (!light_tile) {
          light_tile = new LightTile();
          this.light_map.set_value_at(x, y, light_tile);
        }
        light_tile = light_tile || new LightTile();
        light_tile.light_sources.push(light_source);
        _results.push(light_tile.needs_update = true);
      }
      return _results;
    };

    LightingManager.prototype._light_removed = function(light_source) {
      var light_tile, position, tile_positions, x, y, _i, _len, _results;
      tile_positions = this._get_affected_tile_positions(light_source);
      _results = [];
      for (_i = 0, _len = tile_positions.length; _i < _len; _i++) {
        position = tile_positions[_i];
        x = position[0];
        y = position[1];
        light_tile = this.light_map.get_value_at(x, y);
        if (__indexOf.call(light_tile.light_sources, light_source) >= 0) {
          engine.utils.remove_val_from_array(light_tile.light_sources, light_source);
          _results.push(light_tile.needs_update = true);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    LightingManager.prototype._light_intensity_updated = function(event) {
      var LightTile, intensity, is_new_max, light_source, light_tile, max_affected, max_intensity, max_radius, min_affected, min_intensity, min_radius, position, prev_intensity, _i, _j, _len, _len1, _results;
      light_source = event.target;
      intensity = event.value;
      prev_intensity = event.prev_value;
      max_intensity = Math.max(intensity, prev_intensity);
      max_radius = this._calculate_radius_for_intensity(max_intensity);
      max_affected = this._get_affected_positions_for_origin_and_radius(light_source.x, light_source.y, max_radius);
      min_intensity = Math.min(intensity, prev_intensity);
      min_radius = this._calculate_radius_for_intensity(min_intensity);
      min_affected = this._get_affected_positions_for_origin_and_radius(light_source.x, light_source.y, min_radius);
      is_new_max = intensity > prev_intensity;
      LightTile = this.constructor_for_name("light_tile");
      for (_i = 0, _len = max_affected.length; _i < _len; _i++) {
        position = max_affected[_i];
        light_tile = this.light_map.get_value_at(position[0], position[1]);
        if (!light_tile) {
          light_tile = new LightTile();
          this.light_map.set_value_at(position[0], position[1], light_tile);
        }
        light_tile.needs_update = true;
        if (is_new_max) {
          if (__indexOf.call(light_tile.light_sources, light_source) < 0) {
            light_tile.light_sources.push(light_source);
          }
        } else {
          engine.utils.remove_val_from_array(light_tile.light_sources, light_source);
        }
      }
      _results = [];
      for (_j = 0, _len1 = min_affected.length; _j < _len1; _j++) {
        position = min_affected[_j];
        light_tile = this.light_map.get_value_at(position[0], position[1]);
        if (!is_new_max) {
          light_tile.light_sources.push(light_source);
          _results.push(light_tile.needs_update = true);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    LightingManager.prototype._light_color_updated = function(event) {
      var color, light_source, light_tile, position, _i, _len, _ref, _results;
      light_source = event.target;
      color = event.value;
      _ref = this._get_affected_positions_for_origin_and_radius(light_source.x, light_source.y, this._calculate_radius_for_light_source(light_source));
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        position = _ref[_i];
        light_tile = this.light_map.get_value_at(position[0], position[1]);
        _results.push(light_tile.needs_update = true);
      }
      return _results;
    };

    LightingManager.prototype._light_position_updated = function(event) {
      var light_source, light_tile, position, positions, prev_positions, prev_x, prev_y, x, y, _i, _j, _len, _len1;
      light_source = event.target;
      x = event.x;
      y = event.y;
      prev_x = event.prev_x;
      prev_y = event.prev_y;
      positions = this._get_affected_positions_for_origin_and_radius(x, y, this._calculate_radius_for_light_source(light_source));
      prev_positions = this._get_affected_positions_for_origin_and_radius(prev_x, prev_y, this._calculate_radius_for_light_source(light_source));
      for (_i = 0, _len = prev_positions.length; _i < _len; _i++) {
        position = prev_positions[_i];
        light_tile = this.light_map.get_value_at(position[0], position[1]);
        light_tile.needs_update = true;
        engine.utils.remove_val_from_array(light_tile.light_sources, light_source);
      }
      for (_j = 0, _len1 = positions.length; _j < _len1; _j++) {
        position = positions[_j];
        light_tile = this.light_map.get_value_at(position[0], position[1]);
        if (!light_tile) {
          light_tile = new LightTile();
          this.light_map.set_value_at(position[0], position[1], light_tile);
        }
        light_tile.needs_update = true;
        light_tile.add_light_source(light_source);
      }
    };

    LightingManager.prototype.update = function(bounds) {

      /*
      This will get called externally on each action tick.
      It will iterate through the light map and update any
      light tiles that need updating.
       */
      var updated;
      updated = [];
      this.light_map.for_each((function(_this) {
        return function(light_tile, x, y, bounds) {
          var brightness, distance_from_source, light_source, _i, _len, _ref;
          if (!light_tile.needs_update) {
            return;
          }
          if (bounds && (x < bounds.left || x > bounds.right || y < bounds.top || y > bounds.bottom)) {
            return;
          }
          if (!_this.get_tile_at_handler(x, y)) {
            return;
          }
          light_tile.reset();
          _ref = light_tile.light_sources;
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            light_source = _ref[_i];
            if (_this.has_los_between_points_handler(x, y, light_source.x, light_source.y)) {
              distance_from_source = engine.utils.get_distance_between_points([x, y], [light_source.x, light_source.y]);
              brightness = _this._get_brightness_for_distance_and_intensity(distance_from_source, light_source.intensity);
              if (brightness > 0) {
                light_tile.add_light(light_source.color, brightness);
              }
            }
          }
          return updated.push({
            x: x,
            y: y,
            amount: light_tile.amount
          });
        };
      })(this));
      return updated;
    };

    LightingManager.prototype.light_level_at_point = function(x, y) {
      var light_level, light_tile;
      light_level = 0;
      light_tile = this.light_map.get_value_at(x, y);
      if (light_tile) {
        light_level = light_tile.amount;
      }
      return light_level;
    };

    LightingManager.prototype.light_color_at_point = function(x, y) {
      var light_color, light_level, light_tile;
      light_level = 0;
      light_color = "000000";
      light_tile = this.light_map.get_value_at(x, y);
      if (light_tile) {
        light_color = light_tile.color;
      }
      if (light_tile) {
        light_level = light_tile.amount;
      }
      return light_color;
    };

    return LightingManager;

  })(engine.RegistrySubcategory);

  engine.lighting.LightTile = (function() {
    function LightTile() {
      this.light_sources = [];
      this.reset();
    }

    LightTile.prototype.reset = function() {
      this.amount = 0;
      this.color = "000000";
      return this.needs_update = false;
    };

    LightTile.prototype.add_light_source = function(light_source) {
      if (__indexOf.call(this.light_sources, light_source) < 0) {
        return this.light_sources.push(light_source);
      }
    };

    LightTile.prototype.add_light = function(color, brightness) {
      this.amount += brightness;
      color = engine.utils.multiply_hex_number(color, brightness);
      return this.color = engine.utils.add_hex_colors(this.color, color);
    };

    return LightTile;

  })();

}).call(this);
